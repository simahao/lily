# 浮点数的一些知识

**By zhanghao**

| 版本 | 备注                                                         |    日期    |
| :--: | ------------------------------------------------------------ | :--------: |
| 1.0  | 初始版本                                                     | 2020/11/8  |
| 1.1  | 重构文档结构和内容<br />1. 增加问题章节<br />2. 对浮点数相关概念进行完善<br />3. 对文档逻辑结构进行调整 | 2024/12/30 |

## 1. 问题

1. **问题1**

   对于java代码，下面结果输出是什么？

   ```java
       float fSum = 0.0f;
       for (int i = 0; i < 1000000; i++) {
           fSum += 0.1f;
       }
       System.out.printf("sum:%.3f\n", fSum);
   ```

2. **问题2**

   同样遵守IEEE754浮点数标准，java和C++输出结果是否相同？

   ```c++
       //C++
       double var = 3.425;
       printf("var=%.16f\n", var);
       //Java
       double var = 3.425;
       System.out.printf("var=%.16f\n", var);
   ```

3. **问题3**

   数据库中（oracle）存储的数值为**932.525**，在C++的客户端中保留两位小数显示为**932.52**，但是在基于Javascript的前端保留两位小数后显示**932.53**，谁显示的是对的？

4. **问题4**

   不同的语言，如果涉及到互相调用，浮点型参数传递时，应该如何处理？

5. **问题5**

   Java语言中，为什么BigDecimal就可以表达任意的精度

## 2. IEEE 754简介

### 2.1. 科学计数法

十进制的科学技术法通常用一个数字乘以$$a*10^n$$来表示

- $$57.34=5.734*10^2$$

- $$0.03424=3.424*10^{-2}$$

### 2.2. **有效位数 vs 精度**

两个相关但是不完全相同的概念

1. **有效位数（Significant Digits）**

   有效位数指的是数值中从最高有效位（不为零的第一位）到最后一位的总位数，用于衡量一个数值的**表示范围内的信息量**

   * 数值 `1.234` 有 4 位有效数字

   * 数值 `1.234 × 10³` 有 4 位有效数字

   * 数值 `0.00123` 有 3 位有效数字（前导零不算有效位数）

2. **精度（Precision）**

   **精度**在 IEEE 754 中是一个更广泛的概念，指的是浮点数表示值的**分辨能力**，即能够区分两个相邻数值的能力，同时也表达数字的范围。精度可以分为**绝对精度**和**相对精度**。

 **特点**:

- **绝对精度**:
  表示特定范围内的最小增量（ULP，Unit in the Last Place，单位最小增量）。
  **公式**：绝对精度为$$ULP=2^{e−52}$$（双精度）
- **相对精度**:
  表示分辨能力与数值大小的比值，通常是相对固定的，比如 IEEE 754 双精度浮点数的相对精度是 $$2^{−52}$$
- **动态变化**:
  绝对精度随数值大小和指数变化而变化，但相对精度恒定。

 **示例**:

- 对于数值 1.0 ，其最小增量 $$ULP=2^{-52}$$，绝对精度约为 $$2.22×10^{−16}$$
- 对于数值 10.0，其最小增量 $$ULP=2^{−49}$$，但相对精度仍为 $$2^{−52}$$

**有效位数和精度的区别**

| **属性**       | **有效位数（Significant Digits）**               | **精度（Precision）**                                        |
| -------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| **定义**       | 浮点数表示中有效的、有意义的位数                 | 浮点数在当前范围内的分辨能力，包括绝对精度和相对精度。       |
| **单位**       | 表示数字总共有多少位有效信息（十进制或二进制位） | 表示数值范围内的最小增量（绝对精度）或分辨能力（相对精度）   |
| **固定性**     | 有效位数是固定的（双精度为 53 位二进制有效位）   | 精度动态变化，绝对精度随数值范围变化，而相对精度是固定的     |
| **表现形式**   | 描述浮点数能可靠表示的位数（在十进制或二进制中） | 描述浮点数在特定数值范围的分辨能力（ULP 和相对分辨能力）     |
| **随范围变化** | 不变（固定有效位宽）                             | 绝对精度随指数和数值范围变化，相对精度保持恒定               |
| **设计目的**   | 提供一个固定的位数，用于表示数值中的全部有效信息 | 提供适应动态范围的分辨能力，用于表示浮点数在不同数值范围的精确性 |

### 2.3. 浮点型存储结构

在计算机中，浮点数也利用科学计数法来表达，但是计算机使用二进制，所以就采用二进制的科学计数法来表达。浮点数（双精度64位）存储结构：

![IEEE754_Double_Point](./IEEE_754_Double_Floating_Point_Format.png)

浮点数是由三部分组成，分别是符号位（sign）、指数位（exponent）、尾数（mantissa/fraction）

- **Sign bit: 1 bit**

  符号位决定了数字是正数还是负数，**二进制0代表正数，1代表负数**

- **Exponent: 11 bits**

  指数是由11位组成，代表$$[0,2047]$$（$$2047=2^{11}-1$$）。参考十进制小数的科学计数法（比如说$$3.2×0^{-2}$$），二进制为了表达小数，指数也需要支持负数，通过二进制偏移方法，可以做到这一点。首先解释一下下面表格各个列的含义：
  
  * **存储指数：**浮点数二进制存储结构中，存储的二进制所代表的十进制值
  * **存储指数二进制：**浮点数二进制存储结构中，存储的二进制
  * **实际指数：**通过偏移量方法计算后的十进制数值
  * **实际指数二进制（补码形式）：**通过偏移量方法计算后的二进制数值（补码形式，Two's complement）
  
  我们用一个例子来说明这一点。如果有一个类别的浮点数用4位来表达指数（假想的例子，应该没有这个类别），那么指数的范围为$$e\in[0,2^4-1]$$，已知偏移量公式为$$2^{n-1}-1$$，因此偏移量为7。
  
  偏移量方法要解决的问题是能够表达负指数，同时让正负指数分布范围均等，因此我们让每一个原始的指数都减去偏移量7，这样原本$$[0,15]$$的表达范围变成了$$[-7,8]$$。
  
  
  
  > [!TIP]
  >
  > 关于偏移量，针对不同精度浮点数，有如下信息
  >
  > * **半精度浮点数：**偏移量=$2^{5-1}-1=15$
  > * **单精度浮点数：**偏移量=$2^{7-1}-1=127$
  > * **双精度浮点数：**偏移量=$$2^{11-1}-1=1023$$
  
  
  
  回到双精度浮点数的偏移量，根据公式计算结果，$e\in[2^{0-1023}, 2^{2047-1023}]=e\in[2^{-1023},2^{1024}]$，但是`-1023,1024`是两个特殊的值，`-1023`代表非规格化数据（非规格化数用于表示非常接近于零的数）、`1024`代表负无穷与正无穷（正负靠符号位决定），另外指数位和尾数位如果全为0，则代表数字0（符号位不同区分正0和负0）。所以双精度的指数范围为$e\in[2^{-1022}, 2^{1023}]$，这个指数范围对应到十进制为$e\in[10^{-308}, 10^{308}]$。
  
  
  
  > [!TIP]
  >
  > 为什么是10的308次方呢？
  >
  > $10^x\approx2^{1023}=>x\approx 1023 \times log_{10}^2=>x\approx 308$
  
  
  
  **偏移量方法**


  | 存储指数 | 存储指数二进制 | 实际指数 | 实际指数二进制（Two's complement） |
  | :------: | :------------: | :------: | :--------------------------------: |
  |    15    |      1111      |    8     |                1000                |
  |    14    |      1110      |    7     |                0111                |
  |    13    |      1101      |    6     |                0110                |
  |    12    |      1100      |    5     |                0101                |
  |    11    |      1011      |    4     |                0100                |
  |    10    |      1010      |    3     |                0011                |
  |    9     |      1001      |    2     |                0010                |
  |    8     |      1000      |    1     |                0001                |
  |    7     |      0111      |    0     |                0000                |
  |    6     |      0110      |    −1    |                1111                |
  |    5     |      0101      |    −2    |                1110                |
  |    4     |      0100      |    −3    |                1101                |
  |    3     |      0011      |    −4    |                1100                |
  |    2     |      0010      |    −5    |                1011                |
  |    1     |      0001      |    −6    |                1010                |
  |    0     |      0000      |    −7    |                1001                |

​    


- **Mantissa**: 53 bits (52 explicitly stored)

  留给有效数字的位数实际是52位，但是科学计数法一定是<font color='RED'>$1.b_1b_2...b_n*2^e$</font>，因为科学计数法第一位非零，同时二进制非0及1，因此第一位一定是1。为了扩大有效位数，第一位的1作为固定值（这一位是隐藏值，不需要占用存储位），因此有效位数从52变成53。
  
  
  
  > [!TIP]
  >
  > double的有效位数为15到17位，为什么是15到17位有效数字？
  >
  > $10^x\approx 2^{53}=>x\approx 53\times log_{10}^2=>x\approx16$
  
  

结合以上知识，二进制浮点数表达方式可以有两种方式，分别是二进制方式和十进制方式。其中二进制表达方式更偏向于存储结构；十进制表达偏向于人类的理解和应用程序输出。

- **二进制（Binary）**

  $(-1)^{sign}(1.b_{51}b_{50}b_{49}...b_0)_2\times2^{e-1023}$
- **十进制（Decimal）**

  $(-1)^{sign}\left(1+\sum_{i=1}^{52}b_{52-i}\times2^{-i}\right)\times2^{e-1023}$



针对上面讲述的基础知识，我们通过一些例子进一步加深理解。首先看一下样例的计算过程：

![](./half-precision-floating-point-number-explained.png)



> [!TIP]
>
> 等比数列的求和公式
>
> $S_n=a_1\times\frac{1−r^n}{1-r}$
>
> 其中
>
> * a1：数列的第一项
> * r：公比
> * n：项数

* $0\ 01111111111\ 0000000000000000000000000000000000000000000000000000_2=2^{1023-1023}\times (1+0)=2^0\times 1 = 1$

* $0\ 01111111111\ 0000000000000000000000000000000000000000000000000001_2=2^{1023-1023}\times (1+2^{-52}) \approx 1.0000000000000002$

* $0\ 01111111111\ 0000000000000000000000000000000000000000000000000010_2=2^{1023-1023} \times (1 + 2^{-51}) \approx 1.0000000000000004$

* $1\ 10000000000\ 0000000000000000000000000000000000000000000000000000_2=-2^{1024-1023} \times (1 + 0) = -2$

* $0\ 10000000000\ 1000000000000000000000000000000000000000000000000000_2=2^{1024-1023} \times (1 + 1 \times 2^{-1})=2\times1.5=3$

> [!TIP]
>
> 我们也可以采用移位方法实现二进制->十进制的转化
>
> $2^{1024-1023} \times 1.1_2=2^1 \times 1.1_2 = 11_2 =3$
>
> 二进制乘以2，就好比十进制乘以10，所以$1.1_2\times2^1=11_2=3$



* $0\ 10000000011\ 0111000000000000000000000000000000000000000000000000_2=2^{1027-1023} \times 1.0111_2 = 2^4 \times 1.0111 = 10111_2=2^4+2^2+2^1+2^0=23$

* $0\ 01111111000\ 1000000000000000000000000000000000000000000000000000_2=2^{1016-1023} \times 1.1_2 = 2^{-7} \times 1.1_2 = 0.00000011_2=1 \times 2^{-7} + 1 \times 2^{-8} = \frac{3}{2^8} = 0.01171875$

  

> [!IMPORTANT]
>
> 特殊的数字
>
> * Mininum positve number
>
>   $0\ 00000000001\ 0000000000000000000000000000000000000000000000000000_2=2^{1-1023} \times 1 \approx 2.225 \times 10^{-308}$
>
> * Maximum positive number
>
>   $0\ 11111111110\ 1111111111111111111111111111111111111111111111111111_2=2^{2046-1023} \times (1 + (1 - 2^{-52})) \approx 1.798 \times 10^{308}$
>
>   其中，尾数部分有一部分是$1-2^{-52}$，因为是等比数量求和，可以直接按照公式计算获得
>
>   $2^{-1} + 2^{-2} + ... + 2^{-52} = 2^{-1} \times \left(\frac{1-(2^{-1})^{52}}{1-2^{-1}}\right) =1-2^{-52}$
>
> * **+$\infty$**
>
>   $0\ 11111111111\ 0000000000000000000000000000000000000000000000000000_2=7FF0 0000 0000 0000_{16}=+\infty$
>
> * **-$\infty$**
>
>   $1\ 11111111111\ 0000000000000000000000000000000000000000000000000000_2=FFF0 0000 0000 0000_{16}=-\infty$
>
> * NaN（尾数位只有有不为0的即可，也就是7FFF 0000 0000 0000也是NaN
>
>   $0\ 11111111111\ 1111111111111111111111111111111111111111111111111111_2=7FFF FFFF FFFF FFFF_{16}=NaN$





## 3. 回答问题

* 问题1

  ```java
      float fSum = 0.0f;
      for (int i = 0; i < 1000000; i++) {
          fSum += 0.1f;
      }
      System.out.printf("sum:%.3f\n", fSum);
  
      result
      -----------------
      sum:100958.344
  ```

  对于单精度浮点数0.1，其实计算机并没有办法准确的表达，其二进制表示为

  `0 01111011 10011001100110011001101`，其对应的十进制数为`0.100000001490116119384765625`，经过100w次累计加法，误差被呈现出来。

  > [!TIP]
  >
  > 十进制浮点数0.1如何转化为二进制进行存储？
  >
  > 

* 问题2

  ```java
      //C++
      double var = 3.425;
      printf("var=%.16f\n", var);
  
      result
      ____________________
      var=3.4249999999999998
  
      //Java
      double var = 3.425;
      System.out.printf("var=%.16f\n", var);
  
      result
      ____________________
      var=3.4250000000000000
          
      //Java
      System.out.println(new BigDecimal(var).toPlainString())
      //3.42499999999999982236431605997495353221893310546875
  ```

  ![3.425](./3.425.png)

  这个问题源自C++和Java的输出策略，也就是C++选择遵循原始数据值，而Java选择了遵循人类易于理解的结果。

* 问题3

  数据库中（oracle）存储的数值为**932.525**，在C++的客户端中保留两位小数显示为**932.52**，但是在基于Javascript的前端保留两位小数后显示**932.53**，谁显示的是对的？

* 问题4

  不同的语言，如果涉及到互相调用，浮点型参数传递时，应该如何处理？

* 问题5

  Java语言中，为什么BigDecimal就可以表达任意的精度

  

## 4. 建议

## 5. 其他信息

### 5.1. Java Double类中的常量

```java
public final class Double extends Number implements Comparable<Double> {
    /**
     * A constant holding the positive infinity of type
     * {@code double}. It is equal to the value returned by
     * {@code Double.longBitsToDouble(0x7ff0000000000000L)}.
     */
    public static final double POSITIVE_INFINITY = 1.0 / 0.0;

    /**
     * A constant holding the negative infinity of type
     * {@code double}. It is equal to the value returned by
     * {@code Double.longBitsToDouble(0xfff0000000000000L)}.
     */
    public static final double NEGATIVE_INFINITY = -1.0 / 0.0;

    /**
     * A constant holding a Not-a-Number (NaN) value of type
     * {@code double}. It is equivalent to the value returned by
     * {@code Double.longBitsToDouble(0x7ff8000000000000L)}.
     */
    public static final double NaN = 0.0d / 0.0;

    /**
     * A constant holding the largest positive finite value of type
     * {@code double},
     * (2-2<sup>-52</sup>)&middot;2<sup>1023</sup>.  It is equal to
     * the hexadecimal floating-point literal
     * {@code 0x1.fffffffffffffP+1023} and also equal to
     * {@code Double.longBitsToDouble(0x7fefffffffffffffL)}.
     */
    public static final double MAX_VALUE = 0x1.fffffffffffffP+1023; // 1.7976931348623157e+308

    /**
     * A constant holding the smallest positive normal value of type
     * {@code double}, 2<sup>-1022</sup>.  It is equal to the
     * hexadecimal floating-point literal {@code 0x1.0p-1022} and also
     * equal to {@code Double.longBitsToDouble(0x0010000000000000L)}.
     *
     * @since 1.6
     */
    public static final double MIN_NORMAL = 0x1.0p-1022; // 2.2250738585072014E-308

    /**
     * A constant holding the smallest positive nonzero value of type
     * {@code double}, 2<sup>-1074</sup>. It is equal to the
     * hexadecimal floating-point literal
     * {@code 0x0.0000000000001P-1022} and also equal to
     * {@code Double.longBitsToDouble(0x1L)}.
     */
    public static final double MIN_VALUE = 0x0.0000000000001P-1022; // 4.9e-324

    /**
     * Maximum exponent a finite {@code double} variable may have.
     * It is equal to the value returned by
     * {@code Math.getExponent(Double.MAX_VALUE)}.
     *
     * @since 1.6
     */
    public static final int MAX_EXPONENT = 1023;

    /**
     * Minimum exponent a normalized {@code double} variable may
     * have.  It is equal to the value returned by
     * {@code Math.getExponent(Double.MIN_NORMAL)}.
     *
     * @since 1.6
     */
    public static final int MIN_EXPONENT = -1022;

    /**
     * The number of bits used to represent a {@code double} value.
     *
     * @since 1.5
     */
    public static final int SIZE = 64;
    
    ....
}
```

### 5.2. 参考文档
