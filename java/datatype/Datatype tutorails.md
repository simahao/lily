# 浮点型问题

## code examples

```java
    float fVar = 0.1234567f;
    System.out.printf("7float:%.7f\n", fVar);
    System.out.printf("8float:%.8f\n", fVar);
    System.out.printf("9float:%.9f\n", fVar);

    result
    -----------------
    7float:0.1234567
    8float:0.12345670
    9float:0.123456702


    fVar = 0.12345678f;
    System.out.printf("7float:%.7f\n", fVar);
    System.out.printf("8float:%.8f\n", fVar);
    System.out.printf("9float:%.9f\n", fVar);

    result:
    -----------------
    7float:0.1234568
    8float:0.12345678
    9float:0.123456784

    float fSum = 0.0f;
    fVar = 0.1f;
    for (int i = 0; i < 1000000; i++) {
        fSum += fVar;
    }
    System.out.printf("7float:%.7f\n", fSum);
    System.out.printf("9float:%.9f\n", fSum);

    result:
    ----------------
    7float:100958.3437500
    9float:100958.343750000

    double dVar = 0.12345678901234567;
    System.out.printf("17double:%.17f\n", dVar);
    dVar = 0.123456789012345678;
    System.out.printf("18double:%.18f\n", dVar);

    result:
    ----------------
    17double:0.12345678901234566
    18double:0.123456789012345680



    double dSum = 0.0;
    dVar = 0.1;
    for (int i = 0; i < 1000000; i++) {
        dSum += dVar;
    }
    System.out.printf("17double:%.17f\n", dSum);

    result:
    ---------------
    17double:100000.000001332880000

```

## IEEE754标准

我们熟悉十进制，那么我们如何表达浮点数？

科学技术法：

$$57.34=5.734*10^2$$

$$0.03424=3.424*10^{-2}$$

有效位数：从左边开始第一个非0的数字开始

那么，在计算机中，浮点数也利用这种方式表达浮点数，只是计算机是使用二进制方式来表达。

浮点数(64 bit)存储结构：

![IEEE754_Double_Point](../datatype_png/IEEE_754_Double_Floating_Point_Format.png)

一个浮点数是由三部分组成

- Sign bit: 1 bit

  符号位决定了数字是正数还是负数，二进制0代表正数，1代表负数

- Exponent: 11 bits

  指数是由11 bit组成，代表0~2047，为了表达小数，指数需要支持负数，通过二进制偏移方法，可以做到这一点，比如说excess-8，也就是数字都减去8，这样可以做到想表达的最小负数从0开始，IEEE754选择$excess-(2^n-1)$， 也就是excess-1023进行偏移

    | Decimal | Offset binary K=8 | Two's complement |
    | :-----: | :---------------: | :--------------: |
    |    7    |       1111        |       0111       |
    |    6    |       1110        |       0110       |
    |    5    |       1101        |       0101       |
    |    4    |       1100        |       0100       |
    |    3    |       1011        |       0011       |
    |    2    |       1010        |       0010       |
    |    1    |       1001        |       0001       |
    |    0    |       1000        |       0000       |
    |   −1    |       0111        |       1111       |
    |   −2    |       0110        |       1110       |
    |   −3    |       0101        |       1101       |
    |   −4    |       0100        |       1100       |
    |   −5    |       0011        |       1011       |
    |   −6    |       0010        |       1010       |
    |   −7    |       0001        |       1001       |
    |   −8    |       0000        |       1000       |

    $e\in[2^{-1022}, 2^{1023}]$， 对应到十进制为$e\in[10^{-308}, 10^{308}]$，-1023和+1024保留使用， 为什么是10的308次方呢？
    $$
      10^x\approx2^{1023} \\
      x \approx 1023\times log_{10}^2 \\
      x \approx 308
    $$

- Significand precision: 53 bits (52 explicitly stored)

  留给有效精度的位数实际是52位，但是因为是二进制，所以科学计数法一定是<font color='RED'>$1.b_1b_2...b_n*2^e$</font>，二进制非1即0，因此第一位一定是1，为了扩大精度，第一位的1作为固定值，因此位数从52变成53， double的精度表达范围为15到17位，那么为什么是15到17位有效数字？考虑等式关系：
  $$
    10^x\approx 2^{53}\\
    x\approx 53\times log_{10}2\\
    x \approx 16
  $$

二进制浮点数表达方式：

- binary

  $$(-1)^{sign}(1.b_{51}b_{50}b_{49}...b_0)_2\times2^{e-1023}$$
- decimal

  $$(-1)^{sign}\left(1+\sum_{i=1}^{52}b_{52-i}\times2^{-i}\right)\times2^{e-1023}$$

编码举例：

$0\ 01111111111\ 0000000000000000000000000000000000000000000000000000_2=2^{1023-1023}\times (1+0)=2^0\times 1 = 1$

$0\ 01111111111\ 0000000000000000000000000000000000000000000000000001_2=2^{1023-1023}\times (1+2^{-52}) \approx 1.0000000000000002$

$0\ 01111111111\ 0000000000000000000000000000000000000000000000000010_2=2^{1023-1023} \times (1 + 2^{-51}) \approx 1.0000000000000004$

$1\ 10000000000\ 0000000000000000000000000000000000000000000000000000_2=-2^{1024-1023} \times (1 + 0) = -2$

$0\ 10000000000\ 1000000000000000000000000000000000000000000000000000_2=2^{1024-1023} \times (1 + 1 \times 2^{-1})=2\times1.5=3$

也可以利用位移法：$2^{1024-1023} \times 1.1_2=2^1 \times 1.1_2 = 11_2 =3$

$0\ 10000000011\ 0111000000000000000000000000000000000000000000000000_2=2^{1027-1023} \times 1.0111_2 = 2^4 \times 1.0111 = 10111_2=2^4+2^2+2^1+2^0=23$

$0\ 01111111000\ 1000000000000000000000000000000000000000000000000000_2=2^{1016-1023} \times 1.1_2 = 2^{-7} \times 1.1_2 = 0.00000011_2=1 \times 2^{-7} + 1 \times 2^{-8} = \frac{3}{2^8} = 0.01171875$

**Mininum positve number:**

$0\ 00000000001\ 0000000000000000000000000000000000000000000000000000_2=2^{1-1023} \times 1 \approx 2.225 \times 10^{-308}$

**Maximum positive number:**

$0\ 11111111110\ 1111111111111111111111111111111111111111111111111111_2=2^{2046-1023} \times (1 + (1 - 2^{-52})) \approx 1.798 \times 10^{308}$

$\sum_{i=1}^n2^i=2 \times \frac{1-2^n}{1 -2}$

$2^{-1} + 2^{-2} + ... + 2^{-52} = 2^{-1} \times \left(\frac{1-(1/2)^{52}}{1-2^{-1}}\right) =1-2^{-52}$

**+$\infty$**

$0\ 11111111111\ 0000000000000000000000000000000000000000000000000000_2=7FF0 0000 0000 0000_{16}=+\infty$

**-$\infty$**

$1\ 11111111111\ 0000000000000000000000000000000000000000000000000000_2=FFF0 0000 0000 0000_{16}=-\infty$

$0\ 11111111111\ 1111111111111111111111111111111111111111111111111111_2=7FFF FFFF FFFF FFFF_{16}=NaN$

## float vs double

float为32 bit，double为64 bit，float的精度在6~7 bit，所以在精度和数字表达范围上，float都比较弱，现在的机器内存容量足够，因此程序开发过程中，不要使用float类型

## double vs Double (float vs Float)

Double是double的封装，其中提供了很多属性和方法，有如下类别：

- 属性类
  - 正无穷
  - 负无穷
  - NaN
  - ...
- bit<=>double
- 判断类
  - isNaN
  - isFinite
  - isInfinite
- compare
- parse
- valueOf
- equals
- toString

其中equals是判定两个double的bit完全一致才返回true，而我们在程序判定两个浮点数是否相同，往往要根据小数点保留的位数进行截断再判定，比如：

```JAVA
double a = 1.3456;
double b = 1.3458;
if (abs(a - b) < 0.001) {
    return true;
}
return false;
```

## BigDecimal

Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Double处理，但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。所以开发中，如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。BigDecimal所创建的是对象，故我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。在需要精确的小数计算时再使用BigDecimal，BigDecimal的性能比double和float差，在处理庞大，复杂的运算时尤为明显。故一般精度的计算没必要使用BigDecimal。

```java
BigDecimal a = new BigDecimal(0.1);
System.out.println("a values is:" + a);
System.out.println("=====================");
BigDecimal b = new BigDecimal("0.1");
System.out.println("b values is:" + b);

a values is:0.1000000000000000055511151231257827021181583404541015625
=====================
b values is:0.1
```

## 建议

- web展示类：BigDeciaml

- 计算类
  - 大量计算但没有累计计算：double
  - 累计计算：转成Long，结果再转化为小数
